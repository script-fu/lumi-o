---
title: "รายการ"
type: docs
weight: 4
---
ใน Scheme **รายการ** คือโครงสร้างข้อมูลพื้นฐานที่ใช้ในการจัดกลุ่มค่า รายการคือการเรียงลำดับคอลเลกชันขององค์ประกอบ โดยแต่ละองค์ประกอบสามารถเป็นประเภทใดก็ได้ รวมถึงรายการอื่นด้วย รายการมีการใช้กันอย่างแพร่หลายใน Scheme สำหรับทั้งการจัดเก็บข้อมูลและโครงสร้างของโปรแกรม

### ตัวอย่างที่ 1: รายการอย่างง่าย

```scheme
(list 1 2 3)
```

- สร้างรายการองค์ประกอบสามรายการ: `1`, `2` และ `3`

ผลลัพธ์: **`(1 2 3)`**

---

#### การเข้าถึงองค์ประกอบรายการ

เข้าถึงองค์ประกอบในรายการได้โดยใช้ขั้นตอน `car` และ `cdr`:

- `car` ดึงข้อมูลองค์ประกอบแรกของรายการ
- `cdr` ดึงข้อมูลส่วนที่เหลือของรายการ (ทุกอย่างยกเว้นองค์ประกอบแรก)

#### ตัวอย่าง

```scheme
(define my-list (list 1 2 3))
(car my-list)  ; Retrieves the first element
(cdr my-list)  ; Retrieves the rest of the list
```

ผลลัพธ์:

- `(car my-list)` กลับมา `1`
- `(cdr my-list)` กลับมา `(2 3)`

---

#### การเรียกซ้ำอย่างง่าย: การวนซ้ำผ่านรายการ

ด้วยการเรียก `car` แบบวนซ้ำบน `cdr` ของรายการ คุณสามารถประมวลผลแต่ละองค์ประกอบได้ทีละรายการจนกว่ารายการจะถูกสำรวจ นี่เป็นพื้นฐานของอัลกอริธึมการประมวลผลรายการจำนวนมาก

#### ตัวอย่าง: การพิมพ์แต่ละองค์ประกอบของรายการ

ต่อไปนี้เป็นฟังก์ชันแบบเรียกซ้ำอย่างง่ายในการพิมพ์ทุกองค์ประกอบในรายการ:

```scheme
(define (print-elements lst)
  (if (null? lst)
    (lumi-message "done")
    (begin
      (lumi-message (number->string (car lst))) ;; Print the first element
      (print-elements (cdr lst)))))             ;; Process the rest of the list
```

- **กรณีพื้นฐาน:** หากรายการว่างเปล่า (`null? lst`) ให้หยุดการเรียกซ้ำ
- **กรณีแบบเรียกซ้ำ:** พิมพ์องค์ประกอบแรก (`car lst`) จากนั้นเรียกใช้ฟังก์ชันในส่วนที่เหลือของรายการ (`cdr lst`)

#### ตัวอย่างการใช้งาน

```scheme
(print-elements (list 1 2 3))
```

เอาท์พุท:

- `"1"`
- `"2"`
- `"3"`

ผลลัพธ์: "เสร็จสิ้น"

---

#### มันทำงานอย่างไร

1. ฟังก์ชันดึงข้อมูลองค์ประกอบแรกของรายการโดยใช้ `car` และประมวลผลองค์ประกอบดังกล่าว
2. จากนั้นจะเรียกตัวเองพร้อมกับรายการที่เหลือ (`cdr`)
3. กระบวนการนี้จะทำซ้ำจนกว่ารายการจะว่างเปล่า (`null? lst`)

---

### ตัวอย่างที่ 2: ประเภทผสม

รายการอาจมีองค์ประกอบประเภทต่างๆ รวมถึงสตริง บูลีน ตัวเลข รายการอื่นๆ หรือแม้แต่ผลลัพธ์ของนิพจน์:

```scheme
(list 42 "hello" #t (list 1 2) (+ 3 4))
```

- สิ่งนี้จะสร้างรายการด้วย:
  - ตัวเลข (`42`)
  - สตริง (`"hello"`)
  - บูลีน (`#t`)
  - อีกรายการ (`(1 2)`)
  - ผลลัพธ์ของนิพจน์ (`(+ 3 4)` ซึ่งประเมินเป็น `7`)

ผลลัพธ์: **`(42 "hello" #t (1 2) 7)`**

---

ตัวอย่างเหล่านี้แสดงให้เห็นถึงความเก่งกาจของรายการใน Scheme ทำให้เป็นเครื่องมือที่มีประสิทธิภาพในการจัดระเบียบและจัดการข้อมูล

### รายการการก่อสร้าง

กระบวนการ `cons` ใช้เพื่อสร้างรายการใหม่โดยการรวมองค์ประกอบเข้ากับรายการที่มีอยู่

```scheme
(cons new-element existing-list)
```

#### ตัวอย่าง

```scheme
(cons 0 (list 1 2 3))
```

- เพิ่ม `0` ที่จุดเริ่มต้นของรายการ `(1 2 3)`

ผลลัพธ์: **`(0 1 2 3)`**

---

### กำลังตรวจสอบรายการ

กระบวนการ `list?` จะตรวจสอบว่าค่าที่กำหนดเป็นรายการหรือไม่

```scheme
(list? value)
```

#### ตัวอย่าง: รายการ?

```scheme
(list? (list 1 2 3))  ; Checks if (list 1 2 3) is a list
(list? 42)            ; Checks if 42 is a list
```

ผลลัพธ์:

- `(list? (list 1 2 3))` ส่งกลับ `#t` (จริง)
- `(list? 42)` ส่งคืน `#f` (เท็จ)

---

### การดำเนินงานในรายการ

Scheme มีขั้นตอนในตัวหลายอย่างสำหรับการทำงานกับรายการ ได้แก่:

- `length`: ส่งกลับจำนวนองค์ประกอบในรายการ
- `append`: รวมสองรายการขึ้นไปเป็นรายการเดียว
- `reverse`: ส่งคืนรายการใหม่ที่มีองค์ประกอบในลำดับย้อนกลับ

```scheme
(length (list 1 2 3))          ; Returns 3
(append (list 1 2) (list 3 4)) ; Returns (1 2 3 4)
(reverse (list 1 2 3))         ; Returns (3 2 1)
```

ผลลัพธ์:

- `(length (list 1 2 3))` กลับมา `3`
- `(append (list 1 2) (list 3 4))` กลับมา `(1 2 3 4)`
- `(reverse (list 1 2 3))` กลับมา `(3 2 1)`#### การใช้ `list-ref`

กระบวนการ `list-ref` จะดึงข้อมูลองค์ประกอบที่ดัชนีที่ระบุของรายการ (ดัชนีแบบศูนย์)

```scheme
(list-ref lst index)
```

- **`lst`**: รายการที่จะดึงข้อมูลองค์ประกอบ
- **`index`**: ดัชนีแบบศูนย์ซึ่งระบุองค์ประกอบที่จะส่งคืน

##### ตัวอย่าง: list-ref

```scheme
(list-ref (list 10 20 30 40) 2)  ; Retrieves the element at index 2
```

ผลลัพธ์: `30`

---

### รายการที่ซ้อนกัน

รายการใน Scheme สามารถมีรายการอื่นเป็นองค์ประกอบ ซึ่งสร้างโครงสร้างที่ซ้อนกัน

#### ตัวอย่าง: การสร้างรายการที่ซ้อนกัน

```scheme
(define nested-list (list (list 1 2) (list 3 4) (list 5)))
```

- สร้างรายการองค์ประกอบสามรายการ ซึ่งแต่ละองค์ประกอบก็เป็นรายการของตัวเอง

ผลลัพธ์: **`((1 2) (3 4) (5))`**

---

#### การเข้าถึงข้อมูลที่ซ้อนกัน

หากต้องการเข้าถึงองค์ประกอบภายในรายการที่ซ้อนกัน คุณสามารถใช้ `car` และ `cdr` ร่วมกันเพื่อนำทางผ่านโครงสร้างได้

#### ตัวอย่าง: การเข้าถึงองค์ประกอบ

```scheme
(car nested-list)              ; Retrieves the first element: (1 2)
(car (car nested-list))        ; Retrieves the first element of the first sublist: 1
(cdr (car nested-list))        ; Retrieves the rest of the first sublist: (2)
(car (cdr (car nested-list)))  ; Retrieves the second element of the first sublist: 2
```

---

#### คำอธิบาย

1. **`car nested-list`**:
   - ดึงข้อมูลองค์ประกอบแรกของ `nested-list` ซึ่งก็คือ `(1 2)`

2. **`car (car nested-list)`**:
   - ดึงข้อมูลองค์ประกอบแรกของ `(1 2)` ซึ่งก็คือ `1`

3. **`cdr (car nested-list)`**:
   - ดึงข้อมูลส่วนที่เหลือของ `(1 2)` ซึ่งก็คือ `(2)`

4. **`car (cdr (car nested-list))`**:
   - ดึงข้อมูลองค์ประกอบแรกของ `(2)` ซึ่งก็คือ `2`

---

#### ตัวอย่าง: การเข้าถึงองค์ประกอบจากรายการย่อยอื่น

```scheme
(car (cdr nested-list))        ; Retrieves the second sublist: (3 4)
(car (car (cdr nested-list)))  ; Retrieves the first element of the second sublist: 3
```

---

แนวทางนี้ช่วยให้คุณสามารถนำทางและเข้าถึงองค์ประกอบเฉพาะในรายการที่ซ้อนกันได้อย่างเป็นระบบ ซึ่งให้ความยืดหยุ่นที่มีประสิทธิภาพในการทำงานกับข้อมูลแบบลำดับชั้น

### สรุป

- **รายการ** ใน Scheme เป็นโครงสร้างข้อมูลที่หลากหลายและจำเป็น
- ใช้ `list` เพื่อสร้างรายการ `car` และ `cdr` เพื่อเข้าถึงองค์ประกอบ และใช้ `cons` เพื่อสร้างรายการ
- ขั้นตอนในตัว เช่น `length`, `append`, `reverse` และ `list-ref` ทำให้การดำเนินการรายการง่ายและมีประสิทธิภาพ
- รายการสามารถซ้อนกันได้ ช่วยให้ใช้โครงสร้างข้อมูลที่ซับซ้อนสำหรับกรณีการใช้งานขั้นสูง