---
title: "정의하다"
type: docs
weight: 3
---
Scheme의 `define` 문은 전역 또는 로컬 바인딩을 만드는 데 사용되는 다목적 구성입니다. 변수와 함수를 정의하는 데 가장 일반적으로 사용되며, 이를 통해 스크립트 전체 또는 특정 범위 내에서 재사용 및 액세스할 수 있습니다. `define`을 이해하는 것은 재사용 가능하고 읽기 쉬운 모듈식 Scheme 프로그램을 작성하는 데 중요합니다.

### `define`의 목적

`define` 구성은 다양한 용도로 사용됩니다.
- **변수 정의**: 변수 이름에 값을 할당하여 나중에 사용할 수 있도록 합니다.
- **함수 정의**: 특정 논리를 캡슐화하는 재사용 가능한 프로시저를 만듭니다.
- **로컬 정의**: 함수 내에서 사용될 때 `define`은 전역 네임스페이스에 영향을 주지 않는 로컬 바인딩을 생성합니다.

---

### `define`으로 변수 정의

`define`의 기본 용도는 상수 또는 계산된 값을 보유하는 변수를 생성하는 것입니다.

#### 구문
```scheme
(define variable-name value)
```

#### 예: 상수 정의
```scheme
(define pi 3.14159)
(* pi 2) ;; Computes 2π
```

**결과**: `6.28318`

---

### `define`으로 함수 정의하기

`define`을 사용하여 재사용 가능한 프로시저를 생성할 수 있습니다.

#### 구문
```scheme
(define (function-name parameter1 parameter2 ...)
  body-expression)
```

#### 예: 간단한 함수 정의
```scheme
(define (square x)
  (* x x))
(square 4) ;; Computes 4²
```

**결과**: `16`

---

### `define`을 사용한 지역 정의

함수 내에서 사용될 때 `define`은 바깥쪽 함수 내에서만 액세스할 수 있는 로컬 바인딩을 생성합니다. 이렇게 하면 전역 네임스페이스 오염을 방지하고 코드를 구성하는 데 도움이 됩니다.

#### 예: 로컬 도우미 함수
```scheme
(define (process-values a b c)
  (define (square x) (* x x))  ;; Local helper function
  (define (cube x) (* x x x))  ;; Local helper function
  (+ (square a) (cube b) (square c)))
(process-values 2 3 4)
```

**결과**: `41` (\(2^2 + 3^3 + 4^2\) 계산)

---

### `define`의 주요 기능

1. **글로벌 또는 로컬 범위**:
   - 최상위 수준에서 사용되는 경우 `define`은 전역 변수 또는 함수를 생성합니다.
   - 다른 함수 내에서 사용될 때 `define`은 로컬 바인딩을 생성합니다.

2. **재사용성**:
   - `define`으로 정의된 함수는 다양한 컨텍스트에서 여러 번 재사용될 수 있습니다.

3. **가독성 향상**:
   - 로직을 더 작고 이름이 잘 알려진 함수로 나누면 코드의 명확성과 유지 관리성이 향상됩니다.

---

### `define`과 `let`의 차이점

| **측면** | **`define`** | **`let`** |
|--------------------------------------|------------|--------------------------|
| **목적** | 변수나 함수에 대한 전역 또는 로컬 바인딩을 만듭니다. | 지역화된 범위에서 임시 바인딩을 만듭니다. |
| **범위** | 최상위 수준에서는 전역적입니다. 다른 함수 내부에서는 로컬입니다. | 항상 `let` 블록에 로컬입니다.       |
| **재사용성** | 함수와 변수는 여러 곳에서 재사용될 수 있습니다. | 변수는 단일 블록에 대해 일시적으로 바인딩됩니다. |
| **구문** | 변수나 함수를 명시적으로 정의합니다.       | 변수 바인딩과 표현식 평가를 결합합니다. |