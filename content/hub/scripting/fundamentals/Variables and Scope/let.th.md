---
title: "อนุญาต"
type: docs
weight: 4
---
ชื่อ `let` ถูกใช้เนื่องจากสะท้อนถึงต้นกำเนิดทางคณิตศาสตร์ของการแนะนำการเชื่อมโยงชั่วคราว ดังเช่นใน _"Let \( x = 2 \) และ \( y = 3 \)"_

คำสั่ง `let` ใน Scheme คือ **โครงสร้างการเชื่อมโยง** ที่ใช้เพื่อกำหนดตัวแปรภายในขอบเขตที่แปลเป็นภาษาท้องถิ่น อนุญาตให้คุณสร้างการเชื่อมโยงชั่วคราวสำหรับตัวแปร จากนั้นรันบล็อกของโค้ดโดยใช้การเชื่อมโยงเหล่านั้น สิ่งนี้มีประโยชน์อย่างยิ่งสำหรับการรักษาโค้ดแบบโมดูลาร์และหลีกเลี่ยงมลภาวะที่แปรผันทั่วโลก

`let` ใน Scheme มีรูปแบบหลักสามรูปแบบ:

- **`let`**: อนุญาตมาตรฐานสำหรับการสร้างการเชื่อมโยงภายในเครื่องอย่างง่าย
- **`let*`**: การอนุญาตตามลำดับ โดยที่การเชื่อมโยงอาจขึ้นอยู่กับผลลัพธ์ของการเชื่อมโยงก่อนหน้า
- **ชื่อ `let`**: รูปแบบพิเศษของ `let` ที่สร้างลูปแบบเรียกซ้ำหรือขั้นตอนที่มีชื่อ

ในรูปแบบที่ง่ายที่สุด `let` จะสร้างการเชื่อมโยงตัวแปรโลคัลและประเมินนิพจน์ด้วยการโยงเหล่านั้น

```scheme
(let ((variable1 value1)
      (variable2 value2))
  expression)
```

- **การเชื่อมโยง**: รายการคู่ที่แต่ละคู่กำหนด `value` ให้กับ `variable`
- **นิพจน์**: เนื้อความของ `let` ซึ่งสามารถใช้ตัวแปรที่กำหนดในเครื่องได้

### ตัวอย่าง

```scheme
(let ((x 10)
      (y 20))
  (+ x y))
```

- สิ่งนี้จะกำหนดตัวแปรท้องถิ่นสองตัว `x` (10) และ `y` (20)
- จากนั้นจะคำนวณ `(+ x y)` โดยใช้ตัวแปรเหล่านี้

**ผลลัพธ์**: `30`

---

## `let*` กำลังก่อสร้าง

โครงสร้าง `let*` คล้ายกับ `let` แต่การเชื่อมโยงจะได้รับการประเมิน **ตามลำดับ** ซึ่งหมายความว่าการเชื่อมโยงในภายหลังอาจขึ้นอยู่กับการเชื่อมโยงก่อนหน้านี้

```scheme
(let* ((variable1 value1)
       (variable2 expression-using-variable1))
  expression)
```

### ตัวอย่าง

```scheme
(let* ((x 10)
       (y (+ x 5)))
  (* x y))
```

- การเชื่อมโยงครั้งแรกจะกำหนด `10` ให้กับ `x`
- การเชื่อมโยงครั้งที่สองจะคำนวณ `y` เป็น `(+ x 5)` โดยใช้ค่าของ `x`
- ร่างกายคำนวณ `(* x y)`

**ผลลัพธ์**: `150`

---

## ชื่อ `let`

ชื่อ `let` เป็นรูปแบบพิเศษของ `let` ที่ให้ชื่อสำหรับบล็อก `let` เอง โดยเปลี่ยนให้เป็นขั้นตอนแบบเรียกซ้ำ สิ่งนี้มีประโยชน์สำหรับการสร้างลูปหรือการคำนวณแบบเรียกซ้ำ

```scheme
(let name ((variable1 initial-value1)
           (variable2 initial-value2))
  body-expression)
```

- **ชื่อ**: บล็อก `let` ได้รับการตั้งชื่อ ซึ่งกำหนดฟังก์ชันได้อย่างมีประสิทธิภาพ
- **การเชื่อมโยง**: ค่าเริ่มต้นสำหรับตัวแปร คล้ายกับ `let` มาตรฐาน
- **เนื้อหา**: นิพจน์สามารถเรียกชื่อ `let` ซ้ำได้

### ตัวอย่าง: การวนซ้ำด้วยชื่อ `let`

```scheme
(let loop ((n 5)
           (result 1))
  (if (= n 0)
      result
      (loop (- n 1) (* result n))))
```

- ฟังก์ชัน `loop` เริ่มต้นด้วย `n = 5` และ `result = 1`
- หาก `n` คือ `0` ก็จะส่งคืน `result`
- ไม่เช่นนั้น ระบบจะเรียกตัวเองซ้ำด้วย `n - 1` และ `result * n`

**ผลลัพธ์**: `120` (แฟคทอเรียลจาก 5)

---

## ตารางสรุป| สร้าง | คำอธิบาย | ใช้กรณี |
|------------|----------------------------------------------|------------------------------------------------------------------------------|
| **`let`** | กำหนดการผูกท้องถิ่นสำหรับตัวแปร    | ใช้เมื่อการเชื่อมโยงทั้งหมดเป็นอิสระจากกันและไม่ต้องพึ่งพาซึ่งกันและกัน     |
| **`let*`** | กำหนดการผูกโลคัลตามลำดับ       | ใช้เมื่อการเชื่อมโยงในภายหลังขึ้นอยู่กับผลลัพธ์ของการเชื่อมโยงก่อนหน้านี้           |
| **ชื่อ `let`** | กำหนดขั้นตอนท้องถิ่นแบบเรียกซ้ำ | ใช้สำหรับการวนซ้ำ การคำนวณซ้ำ หรือการเรียกซ้ำในบริบทเฉพาะที่ |

---

## ตัวอย่าง

### การใช้ `let` สำหรับการคำนวณในเครื่อง

```scheme
(let ((x 2)
      (y 3))
  (+ (* x x) (* y y)))
```

**ผลลัพธ์**: `13` (คำนวณ `x² + y²`)

---

### การใช้ `let*` สำหรับการขึ้นต่อกันตามลำดับ

```scheme
(let* ((x 2)
       (y (* x x))
       (z (* y x)))
  z)
```

**ผลลัพธ์**: `8` (คำนวณ `x³`)

---

### การใช้ชื่อ `let` สำหรับการคำนวณแบบเรียกซ้ำ

```scheme
(let factorial ((n 5)
                (result 1))
  (if (= n 0)
      result
      (factorial (- n 1) (* result n))))
```

**ผลลัพธ์**: `120` (แฟกทอเรียลจาก 5)

---

ด้วยการใช้ `let`, `let*` และตั้งชื่อว่า `let` Scheme เปิดใช้งานการเขียนโปรแกรมแบบโมดูลาร์ แบบเรียกซ้ำ และแบบต่อเนื่องโดยมีกฎการกำหนดขอบเขตที่ชัดเจน