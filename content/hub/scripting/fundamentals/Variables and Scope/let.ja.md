---
title: "させて"
type: docs
weight: 4
---
`let` という名前が使用されているのは、_"Let \( x = 2 \) and \( y = 3 \)"_ のように、一時バインディングを導入するという数学的起源を反映しているためです。

Scheme の `let` ステートメントは、ローカライズされたスコープ内の変数を定義するために使用される **バインディング構造** です。これにより、変数の一時的なバインディングを作成し、それらのバインディングを使用してコードのブロックを実行できます。これは、コードをモジュール化してグローバル変数の汚染を回避する場合に特に役立ちます。

Scheme には、`let` の主な形式が 3 つあります。

- **`let`**: 単純なローカル バインディングを作成するための標準レット。
- **`let*`**: シーケンシャル let。バインディングは前のバインディングの結果に依存できます。
- **名前付き `let`**: 再帰ループまたは名前付きプロシージャを作成する `let` の特別な形式。

最も単純な形式では、`let` はローカル変数バインディングを作成し、それらのバインディングを使用して式を評価します。

```scheme
(let ((variable1 value1)
      (variable2 value2))
  expression)
```

- **バインディング**: 各ペアが `value` を `variable` に割り当てるペアのリスト。
- **式**: `let` の本体。ローカルに定義された変数を使用できます。

### 例

```scheme
(let ((x 10)
      (y 20))
  (+ x y))
```

- これは 2 つのローカル変数 `x` (10) と `y` (20) を定義します。
- 次に、これらの変数を使用して `(+ x y)` を計算します。

**結果**: `30`

---

## `let*` 構造

`let*` 構造は `let` に似ていますが、バインディングは **順番に**評価されます。これは、後のバインディングが以前のバインディングに依存できることを意味します。

```scheme
(let* ((variable1 value1)
       (variable2 expression-using-variable1))
  expression)
```

### 例

```scheme
(let* ((x 10)
       (y (+ x 5)))
  (* x y))
```

- 最初のバインディングは、`10` を `x` に割り当てます。
- 2 番目のバインディングは、`x` の値を使用して、`y` を `(+ x 5)` として計算します。
- 本体は `(* x y)` を計算します。

**結果**: `150`

---

## `let` という名前

名前付き `let` は、`let` ブロック自体の名前を提供する `let` の特別な形式であり、ブロックを再帰プロシージャに変換します。これは、ループや再帰的計算を作成する場合に便利です。

```scheme
(let name ((variable1 initial-value1)
           (variable2 initial-value2))
  body-expression)
```

- **名前**: `let` ブロックには名前が付けられ、事実上関数を定義します。
- **バインディング**: 標準の `let` に似た変数の初期値。
- **本文**: 式は名前付き `let` を再帰的に呼び出すことができます。

### 例: `let` という名前のループ

```scheme
(let loop ((n 5)
           (result 1))
  (if (= n 0)
      result
      (loop (- n 1) (* result n))))
```

- `loop` 関数は、`n = 5` と `result = 1` で始まります。
- `n` が `0` の場合、`result` を返します。
- それ以外の場合は、`n - 1` および `result * n` を使用して自分自身を再帰的に呼び出します。

**結果**: `120` (5 の階乗)

---

## サマリーテーブル|構築 |説明 |使用例 |
|----------------------|------------------------------------------|----------------------------------------------------------------------|
| **`let`** |変数のローカル バインディングを定義します。    |すべてのバインディングが独立しており、相互に依存しない場合に使用します。     |
| **`let*`** |シーケンシャルなローカル バインディングを定義します。       |後のバインディングが以前のバインディングの結果に依存する場合に使用します。           |
| **名前は `let`** |再帰的なローカル プロシージャを定義します。 | for ループ、反復計算、またはローカル コンテキストでの再帰を使用します。 |

---

## 例

### `let` をローカル計算に使用する

```scheme
(let ((x 2)
      (y 3))
  (+ (* x x) (* y y)))
```

**結果**: `13` (`x² + y²` を計算)

---

### 順次依存関係に `let*` を使用する

```scheme
(let* ((x 2)
       (y (* x x))
       (z (* y x)))
  z)
```

**結果**: `8` (`x³` を計算)

---

### 再帰的計算に名前付き `let` を使用する

```scheme
(let factorial ((n 5)
                (result 1))
  (if (= n 0)
      result
      (factorial (- n 1) (* result n))))
```

**結果**: `120` (5 の階乗)

---

`let`、`let*`、および `let` を使用することで、Scheme は明確なスコープ ルールを使用したモジュール式、再帰的、および順次プログラミングを可能にします。