---
title: "позволять"
type: docs
weight: 4
---
Имя `let` используется, поскольку оно отражает математическое происхождение введения временных привязок, как в _"Let \( x = 2 \) и \( y = 3 \)"_.

Оператор `let` в Scheme — это **конструкция привязки**, используемая для определения переменных в локализованной области видимости. Он позволяет создавать временные привязки для переменных, а затем выполнять блок кода с использованием этих привязок. Это особенно полезно для сохранения модульности кода и предотвращения загрязнения глобальных переменных.

В Scheme есть три основные формы `let`:

- **`let`**: стандартное разрешение для создания простых локальных привязок.
- **`let*`**: последовательный let, при котором привязки могут зависеть от результатов предыдущих привязок.
- **Имя `let`**: особая форма `let`, которая создает рекурсивные циклы или именованные процедуры.

В своей простейшей форме `let` создает привязки локальных переменных и оценивает выражение с помощью этих привязок.

```scheme
(let ((variable1 value1)
      (variable2 value2))
  expression)
```

- **Привязки**: список пар, в котором каждая пара назначает `value` `variable`.
- **Выражение**: тело `let`, которое может использовать локально определенные переменные.

### Пример

```scheme
(let ((x 10)
      (y 20))
  (+ x y))
```

- Определяет две локальные переменные: `x` (10) и `y` (20).
- Затем он вычисляет `(+ x y)`, используя эти переменные.

**Результат**: `30`

---

## Конструкция `let*`

Конструкция `let*` аналогична конструкции `let`, но привязки оцениваются **последовательно**. Это означает, что более поздние привязки могут зависеть от более ранних.

```scheme
(let* ((variable1 value1)
       (variable2 expression-using-variable1))
  expression)
```

### Пример

```scheme
(let* ((x 10)
       (y (+ x 5)))
  (* x y))
```

- Первая привязка назначает `10` `x`.
- Вторая привязка вычисляет `y` как `(+ x 5)`, используя значение `x`.
- Тело вычисляет `(* x y)`.

**Результат**: `150`

---

## Имя `let`

Именованный `let` — это особая форма `let`, которая предоставляет имя самому блоку `let`, превращая его в рекурсивную процедуру. Это полезно для создания циклов или рекурсивных вычислений.

```scheme
(let name ((variable1 initial-value1)
           (variable2 initial-value2))
  body-expression)
```

- **Имя**: блоку `let` присваивается имя, фактически определяющее функцию.
- **Привязки**: начальные значения переменных, аналогичные стандартным `let`.
- **Тело**: выражение может рекурсивно вызывать указанный `let`.

### Пример: цикл с именем `let`

```scheme
(let loop ((n 5)
           (result 1))
  (if (= n 0)
      result
      (loop (- n 1) (* result n))))
```

- Функция `loop` начинается с `n = 5` и `result = 1`.
- Если `n` равно `0`, возвращается `result`.
- В противном случае он вызывает себя рекурсивно с помощью `n - 1` и `result * n`.

**Результат**: `120` (факториал 5)

---

## Сводная таблица| Построить | Описание | Вариант использования |
|------------|-------------------------------------------|--------------------------------------------------------------------------|
| **`let`** | Определяет локальные привязки для переменных.    | Используйте, когда все привязки независимы и не зависят друг от друга.     |
| **`let*`** | Определяет последовательные локальные привязки.       | Используйте, когда более поздние привязки зависят от результатов более ранних.           |
| **Названо `let`** | Определяет рекурсивные локальные процедуры. | Используйте циклы for, итеративные вычисления или рекурсию в локальном контексте. |

---

## Примеры

### Использование `let` для локальных вычислений

```scheme
(let ((x 2)
      (y 3))
  (+ (* x x) (* y y)))
```

**Результат**: `13` (вычисляет `x² + y²`)

---

### Использование `let*` для последовательных зависимостей

```scheme
(let* ((x 2)
       (y (* x x))
       (z (* y x)))
  z)
```

**Результат**: `8` (вычисляет `x³`)

---

### Использование Named `let` для рекурсивных вычислений

```scheme
(let factorial ((n 5)
                (result 1))
  (if (= n 0)
      result
      (factorial (- n 1) (* result n))))
```

**Результат**: `120` (факториал 5)

---

Используя `let`, `let*` и названный `let`, Scheme обеспечивает модульное, рекурсивное и последовательное программирование с четкими правилами области действия.