---
title: "명명된 let 또는 Local Define"
type: docs
weight: 5
---
**`let`**이라는 이름과 **로컬 `define`**은 모두 코드를 구성하는 Scheme의 강력한 도구이지만 서로 다른 용도로 사용됩니다. 각각을 언제 사용해야 하는지 이해하면 깔끔하고 모듈식이며 효율적인 스크립트를 만드는 데 도움이 됩니다.

### 개요

- **`let`**라는 이름: 지역화된 범위에서 변수 바인딩과 재귀를 결합하는 구문으로 일반적으로 반복 또는 재귀 계산에 사용됩니다.
- **로컬 `define`**: 바깥쪽 함수 범위 내에서 도우미 함수 또는 변수를 정의하여 해당 함수의 여러 부분에서 재사용할 수 있도록 만드는 방법입니다.

---

### 이름은 `let`

#### 특성:
1. 변수 바인딩과 재귀를 단일 구성으로 결합합니다.
2. `let` 블록의 본문으로 범위가 지정됩니다.
3. 단일 작업과 관련된 **국지적 재귀** 또는 반복 프로세스에 이상적입니다.

#### 구문
```scheme
(let name ((variable1 value1)
           (variable2 value2))
  body-expression)
```

#### 예: 목록의 요소 합산
```scheme
(define (sum-list lst)
  (let loop ((remaining lst)
             (accum 0))
    (if (null? remaining)
        accum
        (loop (cdr remaining) (+ accum (car remaining))))))
(sum-list '(1 2 3 4))
```

**결과**: `10`

- **작동 방식**: `loop` 함수는 `let` 내에 정의되어 업데이트된 바인딩으로 재귀 호출을 허용합니다.

---

### 로컬 `define`

#### 특성:
1. 바깥쪽 함수 내에서 재사용할 수 있는 도우미 함수 또는 변수를 생성할 수 있습니다.
2. 둘러싸는 기능으로 범위가 지정되지만 본문 전체에 표시됩니다.
3. 여러 단계 또는 재사용 가능한 논리를 사용하여 코드를 모듈화하는 데 이상적입니다.

#### 구문
```scheme
(define (function-name parameters)
  (define (helper-function parameters)
    body-expression)
  body-expression)
```

#### 예: 여러 값 처리
```scheme
(define (process-values a b c)
  (define (square x) (* x x))  ;; Local helper function
  (define (cube x) (* x x x))  ;; Local helper function
  (+ (square a) (cube b) (square c)))
(process-values 2 3 4)
```

**결과**: `41` (\(2^2 + 3^3 + 4^2\) 계산)

- **작동 방식**: `square` 및 `cube` 도우미 함수는 `process-values` 함수 내에서 재사용 가능하여 모듈식 논리를 활성화합니다.

---

### 주요 차이점

| **측면** | **이름은 `let`** | **로컬 `define`** |
|-------------|-------------------------|----------------------|
| **목적** | 재귀와 반복을 지역화된 방식으로 결합합니다. | 재사용 가능한 도우미 함수 또는 변수를 정의합니다. |
| **범위** | `let` 블록의 본문으로 제한됩니다.           | 둘러싸는 기능 전반에 걸쳐 표시됩니다.      |
| **재사용성** | `let` 블록 외부에서는 재사용할 수 없습니다.             | 함수 내에서 여러 번 재사용할 수 있습니다.    |
| **최고의 사용 사례** | 단일 작업에 연결된 지역화된 재귀 또는 반복입니다. | 재사용 가능한 여러 단계로 코드를 모듈화합니다. |
| **구문** | 바인딩과 재귀를 하나의 구문으로 결합합니다.  | 함수나 변수를 명시적으로 정의합니다.      |

---

### `let`이라는 이름을 사용하는 경우

1. **일회용 논리**: 재귀 또는 반복이 단일 계산에만 해당되는 경우입니다.
2. **캡슐화**: 바깥쪽 함수의 네임스페이스에 추가 함수 이름을 추가하는 것을 방지합니다.
3. **반복**: 반복 구문에서 중간 변수를 관리하는 경우.

**예: 계승 계산**
```scheme
(define (factorial n)
  (let fact ((i n)
             (accum 1))
    (if (= i 0)
        accum
        (fact (- i 1) (* accum i)))))
(factorial 5)
```

**결과**: `120`

---

### 로컬 `define`을 사용해야 하는 경우

1. **재사용 가능한 도우미**: 함수의 여러 부분에서 로직을 재사용해야 하는 경우.
2. **모듈형 설계**: 복잡한 계산을 더 작은 이름의 하위 작업으로 나눕니다.
3. **다중 단계**: 계산의 다양한 부분에 여러 도우미 함수가 필요한 경우.**예: 입력 처리**
```scheme
(define (calculate-values a b)
  (define (add-squares x y)
    (+ (* x x) (* y y)))
  (define (multiply-squares x y)
    (* (* x x) (* y y)))
  (list (add-squares a b) (multiply-squares a b)))
(calculate-values 2 3)
```

**결과**: `(13 36)` (\(2^2 + 3^2\) 및 \(2^2 \cdot 3^2\) 계산)

---

### `let`이라는 이름으로 선언과 입력 결합

명명된 `let`의 가장 강력한 기능 중 하나는 **지역 변수 선언**과 재귀를 위한 **입력 매개변수**를 단일 구문으로 결합하는 기능입니다. 이로 인해 `let`이라는 이름이 반복적이거나 재귀적인 작업에 대해 간결하고 표현력이 풍부해집니다.

#### 지역 변수 선언
명명된 `let`에서 괄호 안의 바인딩은 특정 값으로 초기화되는 **로컬 변수** 역할을 합니다. 이러한 변수의 범위는 `let`의 본문으로 지정됩니다.

```scheme
(let loop ((x 1)   ;; Declares x with initial value 1
           (y 2))  ;; Declares y with initial value 2
  (+ x y))         ;; Uses x and y in the body
```

- **`x` 및 `y`**은 `let`의 일부로 정의되고 초기화되는 지역 변수입니다.

---

#### 재귀를 위한 입력 매개변수
동일한 변수는 `let`이라는 이름의 재귀 호출에 대한 **입력 매개변수** 역할도 합니다. `let`이라는 이름이 자신을 호출하면 이러한 변수가 새 값으로 업데이트됩니다.

```scheme
(let loop ((x 1)
           (y 2))
  (if (> x 5)
    y
    (loop (+ x 1) (* y 2))))  ;; Recursive call with new x and y
```

- **첫 번째 반복**: `x = 1`, `y = 2`
- **두 번째 반복**: `x = 2`, `y = 4`
- **세 번째 반복**: `x = 3`, `y = 8` 등...

---

#### 로컬 `define`을 사용하는 것과 동일합니다.

`let`이라는 이름은 구문의 일부로 변수 초기화를 포함합니다. 이렇게 하면 초기 값을 설정하기 위한 별도의 단계가 필요하지 않습니다. 다음 두 예는 동일합니다.

##### `let` 이름 사용
```scheme
(let loop ((x 1)
           (y 2))
  (if (> x 5)
    y
    (loop (+ x 1) (* y 2))))
```

##### 로컬 사용 `define`
```scheme
(define (outer-function)
  (define (loop x y)
    (if (> x 5)
      y
      (loop (+ x 1) (* y 2))))
  (loop 1 2))  ;; Initial call with x = 1, y = 2
```

둘 다 동일한 계산을 수행하지만 `let`라는 이름은 변수 선언과 재귀 설정을 하나의 간결한 구성으로 결합합니다.

---

#### 선언과 입력 결합의 장점

1. **간결함**: `let`이라는 이름은 변수 초기화와 재귀를 단일 구성으로 병합하여 상용구를 줄입니다.
2. **명확성**: 재귀가 `let`에 국한되고 특정 작업과 연결되어 있음을 분명히 합니다.
3. **캡슐화**: 재귀 논리는 독립적으로 유지되며 포함하는 함수의 네임스페이스를 오염시키지 않습니다.

`let`이라는 이름의 이중 목적 특성(변수 선언 및 재귀 입력 메커니즘 모두)이 이를 Scheme 프로그래밍의 강력하고 고유한 기능으로 만듭니다.

### 요약

- **지역화된 재귀** 또는 **반복**에는 **`let`**이라는 이름을 사용하세요. 특히 로직이 단일 작업에 긴밀하게 결합된 경우 더욱 그렇습니다.
- 재사용 가능한 도우미 함수 또는 변수가 포함된 **코드 모듈화**에는 **로컬 `define`**을 사용하세요.

차이점을 이해하면 보다 간결하고 체계적이며 유지 관리가 쉬운 Scheme 프로그램을 작성할 수 있습니다.