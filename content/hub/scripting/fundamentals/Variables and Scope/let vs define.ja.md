---
title: "名前付き let または Local 定義"
type: docs
weight: 5
---
**`let`** という名前と **ローカル `define`** はどちらもコードを構造化するための Scheme の強力なツールですが、目的は異なります。それぞれをいつ使用するかを理解すると、クリーンでモジュール化された効率的なスクリプトを作成するのに役立ちます。

### 概要

- **`let`** という名前: ローカライズされたスコープで変数バインディングと再帰を組み合わせた構造。通常は反復計算または再帰計算に使用されます。
- **ローカル `define`**: 囲んでいる関数のスコープ内でヘルパー関数または変数を定義し、その関数のさまざまな部分で再利用できるようにする方法。

---

### `let` という名前

#### 特徴:
1. 変数バインディングと再帰を単一の構造に結合します。
2. `let` ブロックの本文をスコープとします。
3. **局所的な再帰**または単一タスクに固有の反復プロセスに最適です。

#### 構文
```scheme
(let name ((variable1 value1)
           (variable2 value2))
  body-expression)
```

#### 例: リストの要素の合計
```scheme
(define (sum-list lst)
  (let loop ((remaining lst)
             (accum 0))
    (if (null? remaining)
        accum
        (loop (cdr remaining) (+ accum (car remaining))))))
(sum-list '(1 2 3 4))
```

**結果**: `10`

- **仕組み**: `loop` 関数は `let` 内で定義されており、更新されたバインディングでの再帰呼び出しが可能です。

---

### ローカル `define`

#### 特徴:
1. 囲んでいる関数内で再利用できるヘルパー関数または変数の作成を許可します。
2. 範囲は​​囲んでいる関数に限定されますが、その本体全体に表示されます。
3. 複数のステップまたは再利用可能なロジックを含むコードのモジュール化に最適です。

#### 構文
```scheme
(define (function-name parameters)
  (define (helper-function parameters)
    body-expression)
  body-expression)
```

#### 例: 複数の値の処理
```scheme
(define (process-values a b c)
  (define (square x) (* x x))  ;; Local helper function
  (define (cube x) (* x x x))  ;; Local helper function
  (+ (square a) (cube b) (square c)))
(process-values 2 3 4)
```

**結果**: `41` (\(2^2 + 3^3 + 4^2\) を計算します)

- **仕組み**: ヘルパー関数 `square` および `cube` は `process-values` 関数内で再利用可能であり、モジュラー ロジックが有効になります。

---

### 主な違い

| **側面** | **名前は `let`** | **ローカル `define`** |
|-------------------------------------|--------------------------------------------|------------------------------------------------|
| **目的** |局所的な方法で再帰と反復を組み合わせます。 |再利用可能なヘルパー関数または変数を定義します。 |
| **範囲** | `let` ブロックの本文に限定されます。           |囲んでいる関数全体で表示されます。      |
| **再利用性** | `let` ブロックの外では再利用できません。             |関数内で何度でも再利用可能。    |
| **ベストユースケース** |単一のタスクに関連付けられた局所的な再帰または反復。 |複数の再利用可能なステップによるコードのモジュール化。 |
| **構文** |バインディングと再帰を 1 つの構造に結合します。  |関数または変数を明示的に定義します。      |

---

### 名前付き `let` を使用する場合

1. **単一使用ロジック**: 再帰または反復が単一の計算に固有の場合。
2. **カプセル化**: 囲んでいる関数の名前空間に余分な関数名が追加されるのを避けるため。
3. **反復**: ループ構造内の中間変数を管理する場合。

**例: 階乗計算**
```scheme
(define (factorial n)
  (let fact ((i n)
             (accum 1))
    (if (= i 0)
        accum
        (fact (- i 1) (* accum i)))))
(factorial 5)
```

**結果**: `120`

---

### ローカル `define` を使用する場合

1. **再利用可能なヘルパー**: 関数の複数の部分でロジックを再利用する必要がある場合。
2. **モジュール設計**: 複雑な計算を、名前付きの小さなサブタスクに分割します。
3. **複数のステップ**: 計算のさまざまな部分に複数のヘルパー関数が必要な場合。**例: 入力の処理**
```scheme
(define (calculate-values a b)
  (define (add-squares x y)
    (+ (* x x) (* y y)))
  (define (multiply-squares x y)
    (* (* x x) (* y y)))
  (list (add-squares a b) (multiply-squares a b)))
(calculate-values 2 3)
```

**結果**: `(13 36)` (\(2^2 + 3^2\) と \(2^2 \cdot 3^2\) を計算します)

---

### 名前付き `let` での宣言と入力の結合

名前付き `let` の最も強力な機能の 1 つは、**ローカル変数宣言** と再帰用の **入力パラメーター** を 1 つの構造に結合できることです。これにより、名前付き `let` が反復タスクまたは再帰タスクに対して簡潔かつ表現力豊かになります。

#### ローカル変数の宣言
名前付き `let` では、括弧内のバインディングは、特定の値で初期化される **ローカル変数** として機能します。これらの変数のスコープは、`let` の本体に限定されます。

```scheme
(let loop ((x 1)   ;; Declares x with initial value 1
           (y 2))  ;; Declares y with initial value 2
  (+ x y))         ;; Uses x and y in the body
```

- **`x` および `y`** は、`let` の一部として定義および初期化されるローカル変数です。

---

#### 再帰の入力パラメータ
同じ変数は、名前付き `let` への再帰呼び出しの **入力パラメータ**としても機能します。名前付き `let` が自分自身を呼び出すと、これらの変数が新しい値で更新されます。

```scheme
(let loop ((x 1)
           (y 2))
  (if (> x 5)
    y
    (loop (+ x 1) (* y 2))))  ;; Recursive call with new x and y
```

- **最初の反復**: `x = 1`、`y = 2`
- **2 回目の反復**: `x = 2`、`y = 4`
- **3 回目の反復**: `x = 3`、`y = 8` など...

---

#### ローカル `define` を使用した場合と同等

名前付き `let` には、構文の一部として変数の初期化が含まれています。これにより、初期値を設定するための別の手順が不要になります。次の 2 つの例は同等です。

##### 名前付き `let` を使用
```scheme
(let loop ((x 1)
           (y 2))
  (if (> x 5)
    y
    (loop (+ x 1) (* y 2))))
```

##### ローカル `define` を使用する
```scheme
(define (outer-function)
  (define (loop x y)
    (if (> x 5)
      y
      (loop (+ x 1) (* y 2))))
  (loop 1 2))  ;; Initial call with x = 1, y = 2
```

どちらも同じ計算を実行しますが、名前付きの `let` は、変数宣言と再帰セットアップを 1 つの簡潔な構造に結合します。

---

#### 宣言と入力を組み合わせる利点

1. **簡潔さ**: `let` という名前は、変数の初期化と再帰を 1 つの構造にマージすることで定型文を削減します。
2. **明確さ**: 再帰が `let` に対してローカルであり、特定のタスクに関連付けられていることが明確になります。
3. **カプセル化**: 再帰ロジックは自己完結型のままであり、外側の関数の名前空間を汚染しません。

名前付き `let` のこの二重目的の性質 (変数宣言と再帰入力メカニズムの両方) が、これを Scheme プログラミングにおける強力でユニークな機能にしています。

### 概要

- 特にロジックが 1 つのタスクに密結合している場合は、**局所的な再帰** または **反復** には **名前付き `let`** を使用します。
- 再利用可能なヘルパー関数または変数を使用して **コードをモジュール化**するには、**ローカル `define`** を使用します。

それらの違いを理解することで、より簡潔で、整理され、保守しやすい Scheme プログラムを作成できます。