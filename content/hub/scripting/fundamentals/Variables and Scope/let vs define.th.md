---
title: "ชื่อให้หรือกำหนดท้องถิ่น"
type: docs
weight: 5
---
ทั้ง **ชื่อ `let`** และ **local `define`** เป็นเครื่องมือที่มีประสิทธิภาพใน Scheme สำหรับการจัดโครงสร้างโค้ดของคุณ แต่มีวัตถุประสงค์ที่แตกต่างกัน การทำความเข้าใจว่าเมื่อใดควรใช้แต่ละอย่างในการสร้างสคริปต์ที่ดูสะอาดตา แบบโมดูลาร์ และมีประสิทธิภาพ

### ภาพรวม

- **ชื่อ `let`**: โครงสร้างที่รวมการเชื่อมโยงตัวแปรและการเรียกซ้ำในขอบเขตที่แปลเป็นภาษาท้องถิ่น โดยทั่วไปจะใช้สำหรับการคำนวณแบบวนซ้ำหรือแบบเรียกซ้ำ
- **Local `define`**: วิธีการกำหนดฟังก์ชันตัวช่วยหรือตัวแปรภายในขอบเขตของฟังก์ชันปิดล้อม ทำให้สามารถนำกลับมาใช้ใหม่ได้ในส่วนต่างๆ ของฟังก์ชันนั้น

---

### ชื่อ `let`

#### ลักษณะ:
1. รวมการเชื่อมโยงตัวแปรและการเรียกซ้ำไว้ในโครงสร้างเดียว
2. กำหนดขอบเขตไว้ที่ส่วนเนื้อหาของบล็อก `let`
3. เหมาะสำหรับ **การเรียกซ้ำแบบแปลเป็นภาษาท้องถิ่น** หรือกระบวนการวนซ้ำที่เฉพาะเจาะจงสำหรับงานเดียว

#### ไวยากรณ์
```scheme
(let name ((variable1 value1)
           (variable2 value2))
  body-expression)
```

#### ตัวอย่าง: การรวมองค์ประกอบของรายการ
```scheme
(define (sum-list lst)
  (let loop ((remaining lst)
             (accum 0))
    (if (null? remaining)
        accum
        (loop (cdr remaining) (+ accum (car remaining))))))
(sum-list '(1 2 3 4))
```

**ผลลัพธ์**: `10`

- **วิธีการทำงาน**: ฟังก์ชัน `loop` ถูกกำหนดไว้ภายใน `let` ซึ่งช่วยให้สามารถเรียกซ้ำพร้อมการเชื่อมโยงที่อัปเดตแล้ว

---

### ท้องถิ่น `define`

#### ลักษณะ:
1. อนุญาตให้สร้างฟังก์ชันตัวช่วยหรือตัวแปรที่สามารถนำมาใช้ซ้ำได้ภายในฟังก์ชันปิดล้อม
2. กำหนดขอบเขตไว้ที่ฟังก์ชันปิดล้อมแต่มองเห็นได้ทั่วร่างกาย
3. เหมาะสำหรับการสร้างโค้ดแบบโมดูลาร์ที่มีหลายขั้นตอนหรือตรรกะที่นำมาใช้ซ้ำได้

#### ไวยากรณ์
```scheme
(define (function-name parameters)
  (define (helper-function parameters)
    body-expression)
  body-expression)
```

#### ตัวอย่าง: การประมวลผลหลายค่า
```scheme
(define (process-values a b c)
  (define (square x) (* x x))  ;; Local helper function
  (define (cube x) (* x x x))  ;; Local helper function
  (+ (square a) (cube b) (square c)))
(process-values 2 3 4)
```

**ผลลัพธ์**: `41` (คำนวณ \(2^2 + 3^3 + 4^2\))

- **วิธีการทำงาน**: ฟังก์ชันตัวช่วย `square` และ `cube` สามารถนำมาใช้ซ้ำได้ภายในฟังก์ชัน `process-values` ซึ่งช่วยให้ใช้งานตรรกะแบบโมดูลาร์ได้

---

### ความแตกต่างที่สำคัญ

| **มุมมอง** | **ชื่อ `let`** | **ท้องถิ่น `define`** |
|----------------------------------|--------------------------------------------------|------------------------------------------------|
| **วัตถุประสงค์** | รวมการเรียกซ้ำและการวนซ้ำในลักษณะท้องถิ่น | กำหนดฟังก์ชันหรือตัวแปรตัวช่วยที่ใช้ซ้ำได้ |
| **ขอบเขต** | จำกัดเฉพาะเนื้อหาของบล็อก `let`           | มองเห็นได้ตลอดทั้งฟังก์ชันการปิดล้อม      |
| **การนำกลับมาใช้ใหม่** | ไม่สามารถใช้ซ้ำนอกบล็อก `let`             | นำมาใช้ใหม่ได้หลายครั้งภายในฟังก์ชัน    |
| **กรณีการใช้งานที่ดีที่สุด** | การเรียกซ้ำหรือการวนซ้ำที่แปลเป็นภาษาท้องถิ่นซึ่งเชื่อมโยงกับงานเดียว | การทำให้โค้ดเป็นแบบโมดูลาร์ด้วยขั้นตอนที่นำมาใช้ซ้ำได้หลายขั้นตอน |
| **ไวยากรณ์** | รวมการเชื่อมโยงและการเรียกซ้ำไว้ในโครงสร้างเดียว  | กำหนดฟังก์ชันหรือตัวแปรอย่างชัดเจน      |

---

### เมื่อใดควรใช้ชื่อ `let`

1. **ตรรกะแบบใช้ครั้งเดียว**: เมื่อการเรียกซ้ำหรือการวนซ้ำมีผลเฉพาะกับการคำนวณครั้งเดียว
2. **การห่อหุ้ม**: เพื่อหลีกเลี่ยงการเพิ่มชื่อฟังก์ชันเพิ่มเติมให้กับเนมสเปซของฟังก์ชันที่ปิดล้อม
3. **การทำซ้ำ**: เมื่อจัดการตัวแปรระดับกลางในโครงสร้างการวนซ้ำ

**ตัวอย่าง: การคำนวณแฟกทอเรียล**
```scheme
(define (factorial n)
  (let fact ((i n)
             (accum 1))
    (if (= i 0)
        accum
        (fact (- i 1) (* accum i)))))
(factorial 5)
```

**ผลลัพธ์**: `120`

---

### เมื่อใดควรใช้ Local `define`

1. **ตัวช่วยที่ใช้ซ้ำได้**: เมื่อจำเป็นต้องใช้ตรรกะซ้ำในหลายส่วนของฟังก์ชัน
2. **การออกแบบแบบโมดูลาร์**: เพื่อแบ่งการคำนวณที่ซับซ้อนออกเป็นงานย่อยที่มีชื่อว่ามีขนาดเล็กลง
3. **หลายขั้นตอน**: เมื่อจำเป็นต้องใช้ฟังก์ชันตัวช่วยหลายตัวสำหรับส่วนต่างๆ ของการคำนวณ**ตัวอย่าง: กำลังประมวลผลอินพุต**
```scheme
(define (calculate-values a b)
  (define (add-squares x y)
    (+ (* x x) (* y y)))
  (define (multiply-squares x y)
    (* (* x x) (* y y)))
  (list (add-squares a b) (multiply-squares a b)))
(calculate-values 2 3)
```

**ผลลัพธ์**: `(13 36)` (คำนวณ \(2^2 + 3^2\) และ \(2^2 \cdot 3^2\))

---

### การรวมการประกาศและการป้อนข้อมูลในชื่อ `let`

หนึ่งในคุณสมบัติที่ทรงพลังที่สุดของ `let` ที่มีชื่อก็คือความสามารถในการรวม **การประกาศตัวแปรโลคัล** และ **พารามิเตอร์อินพุต** สำหรับการเรียกซ้ำเป็นโครงสร้างเดียว ซึ่งทำให้ชื่อ `let` มีความกระชับและชัดเจนสำหรับงานที่วนซ้ำหรือเรียกซ้ำ

#### การประกาศตัวแปรท้องถิ่น
ใน `let` ที่มีชื่อ การผูกในวงเล็บจะทำหน้าที่เป็น **ตัวแปรภายในเครื่อง** ที่ถูกเตรียมใช้งานด้วยค่าเฉพาะ ตัวแปรเหล่านี้กำหนดขอบเขตไว้ที่ส่วนเนื้อหาของ `let`

```scheme
(let loop ((x 1)   ;; Declares x with initial value 1
           (y 2))  ;; Declares y with initial value 2
  (+ x y))         ;; Uses x and y in the body
```

- **`x` และ `y`** เป็นตัวแปรท้องถิ่นที่กำหนดและเริ่มต้นโดยเป็นส่วนหนึ่งของ `let`

---

#### พารามิเตอร์อินพุตสำหรับการเรียกซ้ำ
ตัวแปรเดียวกันยังทำหน้าที่เป็น **พารามิเตอร์อินพุต** สำหรับการเรียกซ้ำไปยัง `let` ที่มีชื่อ เมื่อ `let` ที่มีชื่อเรียกตัวเอง มันจะอัปเดตตัวแปรเหล่านี้ด้วยค่าใหม่

```scheme
(let loop ((x 1)
           (y 2))
  (if (> x 5)
    y
    (loop (+ x 1) (* y 2))))  ;; Recursive call with new x and y
```

- **การทำซ้ำครั้งแรก**: `x = 1`, `y = 2`
- **การทำซ้ำครั้งที่สอง**: `x = 2`, `y = 4`
- **การทำซ้ำครั้งที่สาม**: `x = 3`, `y = 8` และอื่นๆ...

---

#### เทียบเท่ากับการใช้ Local `define`

ชื่อ `let` มีการกำหนดค่าเริ่มต้นของตัวแปรเป็นส่วนหนึ่งของไวยากรณ์ ซึ่งช่วยลดความจำเป็นในการตั้งค่าเริ่มต้นแยกต่างหาก สองตัวอย่างต่อไปนี้เทียบเท่ากัน:

##### ใช้ชื่อ `let`
```scheme
(let loop ((x 1)
           (y 2))
  (if (> x 5)
    y
    (loop (+ x 1) (* y 2))))
```

##### การใช้ท้องถิ่น `define`
```scheme
(define (outer-function)
  (define (loop x y)
    (if (> x 5)
      y
      (loop (+ x 1) (* y 2))))
  (loop 1 2))  ;; Initial call with x = 1, y = 2
```

ทั้งสองทำการคำนวณแบบเดียวกัน แต่ชื่อ `let` รวมการประกาศตัวแปรและการตั้งค่าการเรียกซ้ำไว้ในโครงสร้างเดียวที่กระชับ

---

#### ข้อดีของการรวมการประกาศและการป้อนข้อมูล

1. **ความกระชับ**: ชื่อ `let` ลดขนาดสำเร็จรูปโดยการรวมการกำหนดค่าเริ่มต้นและการเรียกซ้ำของตัวแปรไว้ในโครงสร้างเดียว
2. **ความชัดเจน**: ทำให้ชัดเจนว่าการเรียกซ้ำเกิดขึ้นภายในเครื่อง `let` และเชื่อมโยงกับงานเฉพาะ
3. **การห่อหุ้ม**: ตรรกะแบบเรียกซ้ำยังคงมีอยู่ในตัวเอง และไม่ทำให้เนมสเปซของฟังก์ชันการปิดล้อมเสียหาย

ลักษณะการใช้งานอเนกประสงค์ของ `let` ซึ่งเป็นทั้งการประกาศตัวแปรและกลไกการป้อนข้อมูลแบบเรียกซ้ำ เป็นสิ่งที่ทำให้เป็นคุณลักษณะที่ทรงพลังและเป็นเอกลักษณ์ในการเขียนโปรแกรม Scheme

### สรุป

- ใช้ **ชื่อ `let`** สำหรับ **การเรียกซ้ำแบบแปลเป็นภาษาท้องถิ่น** หรือ **การวนซ้ำ** โดยเฉพาะอย่างยิ่งเมื่อตรรกะเชื่อมโยงกับงานเดียวอย่างแน่นหนา
- ใช้ **local `define`** สำหรับ **การปรับโค้ดแบบโมดูลาร์** ด้วยฟังก์ชันตัวช่วยหรือตัวแปรที่ใช้ซ้ำได้

โดยการทำความเข้าใจความแตกต่างเหล่านี้ คุณสามารถเขียนโปรแกรม Scheme ที่กระชับ เป็นระเบียบ และบำรุงรักษาได้มากขึ้น