---
title: "состояние"
type: docs
weight: 5
---
В Scheme условное выражение `cond` используется для выбора одного из нескольких возможных блоков кода для выполнения на основе нескольких тестов. Это похоже на мульти-ветвь `if`, где каждая ветвь проверяется по порядку, пока не будет найдено совпадение.

### Синтаксис

```scheme
(cond
  (test-1 consequent-1)
  (test-2 consequent-2)
  ...
  (else fallback-consequent))
```

- Каждый тест оценивается в том порядке, в котором они написаны.
- Когда результат теста оказывается истинным (`#t`), выполняется соответствующее **последовательность**, и выражение `cond` перестает оценивать дальнейшие тесты.
- Предложение `else` является необязательным и служит запасным вариантом, если ни один из тестов не дает истинного результата.

### Как это работает

1. **Проверьте каждое условие**:
   - `cond` оценивает тесты в том порядке, в котором они перечислены.

2. **Выполнить следствие сопоставления**:
   - Когда найден первый тест, который имеет истинное значение (`#t`), выполняется его **последующий**.
   - Если ни один тест не дает истинного результата и имеется предложение `else`, выполняется **fallback-consequent**.

### Примеры

#### Пример 1: последствия одного выражения

```scheme
(cond
  ((< 3 2) "This won't run")
  ((= 3 3) "This will run")
  (else "Fallback"))
```

- Первый тест `(< 3 2)` оценивается как ложный (`#f`).
- Второй тест `(= 3 3)` оценивается как true (`#t`), поэтому возвращается `"This will run"`.
- Предложение `else` не выполняется, поскольку совпадение уже найдено.

Результат: **"Это будет выполнено"**

#### Пример 2: Несколько действий с использованием `begin`

Если следствие включает в себя несколько действий, используйте `begin`, чтобы сгруппировать их:

```scheme
(cond
  ((< 5 3)
    (begin
      (lumi-message "This won't run")
      (* 2 3)))
  ((> 5 3)
    (begin
      (lumi-message "Condition met")
      (* 5 5)))
  (else
    (begin
      (lumi-message "Fallback")
      0)))
```

- Первый тест `(< 5 3)` оценивается как ложный (`#f`).
- Второй тест `(> 5 3)` оценивается как истинный (`#t`):
  - Он печатает `"Condition met"`.
  - Затем он вычисляет `(* 5 5)` и возвращает `25`.

Результат: **Печатает «Условие выполнено» и возвращает 25.**

#### Пример 3: Использование блока `let` в последовательном

Если вам нужно ввести локальные переменные, используйте блок `let`:

```scheme
(cond
  ;; Case 1: If 0 is less than -1
  ((< 0 -1)
    (let ((x 10))
      (* x x)))

  ;; Case 2: If 0 is greater than -1
  ((> 0 -1)
    (let ((y 20))
      (lumi-message "Positive condition met")
      (+ y y)))

  ;; Default case: If none of the above conditions are met
  (else
    (let ((z 0))
      z)))
```

- Первый тест `(< 0 -1)` является ложным.
- Второй тест `(> 0 -1)` верен, поэтому:
  - Выполняется блок `let`, связывающий `y` с `20`.
  - Он печатает `"Positive condition met"`.
  - Затем он вычисляет `(+ y y)` и возвращает `40`.

Результат: **Печатает «Положительное условие выполнено» и возвращает 40.**

#### Пример 4: Резервный вариант с `else`

```scheme
(cond
  ((< 5 3) "This won't run")
  ((= 5 3) "This won't run either")
  (else "Fallback value"))
```

- Ни один из первых двух тестов не дает верных результатов.
- Предложение `else` выполняется и возвращает `"Fallback value"`.

Результат: **"Резервное значение"**

### Резюме

- Используйте `cond` для четкой и краткой обработки множества условий.
- Последствиями могут быть отдельные выражения или сгруппированные действия с использованием `begin`.
- Используйте `let` в консеквентах, чтобы объявить локальные переменные для вычислений.
- Всегда включайте предложение `else` в качестве запасного варианта на случай непредвиденных случаев.

Такая гибкость делает `cond` мощным и понятным инструментом для обработки сложной логики ветвления.