---
title: "เงื่อนไข"
type: docs
weight: 5
---
ใน Scheme เงื่อนไข `cond` ใช้สำหรับเลือกหนึ่งในหลายบล็อกของโค้ดที่เป็นไปได้เพื่อดำเนินการ โดยอิงจากการทดสอบหลายครั้ง มันเหมือนกับ `if` หลายสาขา โดยแต่ละสาขาจะถูกตรวจสอบตามลำดับจนกว่าจะพบรายการที่ตรงกัน

### ไวยากรณ์

```scheme
(cond
  (test-1 consequent-1)
  (test-2 consequent-2)
  ...
  (else fallback-consequent))
```

- การทดสอบแต่ละครั้งจะได้รับการประเมินตามลำดับที่เขียน
- เมื่อการทดสอบประเมินเป็นจริง (`#t`) **ผลที่ตามมา** ที่เกี่ยวข้องจะถูกดำเนินการ และนิพจน์ `cond` จะหยุดประเมินการทดสอบเพิ่มเติม
- ส่วนคำสั่ง `else` เป็นทางเลือกและทำหน้าที่เป็นทางเลือกสำรอง หากไม่มีการทดสอบใดประเมินว่าเป็นจริง

### มันทำงานอย่างไร

1. **ทดสอบแต่ละเงื่อนไข**:
   - `cond` ประเมินการทดสอบตามลำดับที่แสดง

2. **ดำเนินการผลการจับคู่**:
   - เมื่อพบการทดสอบแรกที่ประเมินว่าเป็นจริง (`#t`) **ผลที่ตามมา** จะถูกดำเนินการ
   - หากไม่มีการทดสอบใดประเมินว่าเป็นจริงและมี `else` ส่วนคำสั่ง **ผลที่ตามมาสำรอง** จะถูกดำเนินการ

### ตัวอย่าง

#### ตัวอย่างที่ 1: ผลที่ตามมาของนิพจน์เดี่ยว

```scheme
(cond
  ((< 3 2) "This won't run")
  ((= 3 3) "This will run")
  (else "Fallback"))
```

- การทดสอบครั้งแรก `(< 3 2)` ประเมินว่าเป็นเท็จ (`#f`)
- การทดสอบครั้งที่สอง `(= 3 3)` ประเมินเป็นจริง (`#t`) ดังนั้น `"This will run"` จึงถูกส่งกลับ
- ส่วนคำสั่ง `else` ไม่ได้ถูกดำเนินการเนื่องจากพบรายการที่ตรงกันแล้ว

ผลลัพธ์: **"สิ่งนี้จะทำงาน"**

#### ตัวอย่างที่ 2: การดำเนินการหลายอย่างโดยใช้ `begin`

เมื่อผลที่ตามมาเกี่ยวข้องกับการกระทำหลายอย่าง ให้ใช้ `begin` เพื่อจัดกลุ่ม:

```scheme
(cond
  ((< 5 3)
    (begin
      (lumi-message "This won't run")
      (* 2 3)))
  ((> 5 3)
    (begin
      (lumi-message "Condition met")
      (* 5 5)))
  (else
    (begin
      (lumi-message "Fallback")
      0)))
```

- การทดสอบครั้งแรก `(< 5 3)` ประเมินว่าเป็นเท็จ (`#f`)
- การทดสอบครั้งที่สอง `(> 5 3)` ประเมินเป็นจริง (`#t`):
  - พิมพ์ `"Condition met"`
  - จากนั้นจะคำนวณ `(* 5 5)` และส่งคืน `25`

ผลลัพธ์: **พิมพ์ "ตรงตามเงื่อนไข" และส่งคืน 25.**

#### ตัวอย่างที่ 3: การใช้ `let` บล็อกในผลที่ตามมา

เมื่อคุณต้องการแนะนำตัวแปรในเครื่อง ให้ใช้บล็อก `let`:

```scheme
(cond
  ;; Case 1: If 0 is less than -1
  ((< 0 -1)
    (let ((x 10))
      (* x x)))

  ;; Case 2: If 0 is greater than -1
  ((> 0 -1)
    (let ((y 20))
      (lumi-message "Positive condition met")
      (+ y y)))

  ;; Default case: If none of the above conditions are met
  (else
    (let ((z 0))
      z)))
```

- การทดสอบครั้งแรก `(< 0 -1)` เป็นเท็จ
- การทดสอบครั้งที่สอง `(> 0 -1)` เป็นจริง ดังนั้น:
  - บล็อก `let` ได้ถูกดำเนินการ โดยเชื่อมโยง `y` กับ `20`
  - พิมพ์ `"Positive condition met"`
  - จากนั้นจะคำนวณ `(+ y y)` และส่งคืน `40`

ผลลัพธ์: **พิมพ์ "ตรงตามเงื่อนไขที่เป็นบวก" และส่งกลับ 40.**

#### ตัวอย่างที่ 4: ทางเลือกสำรองด้วย `else`

```scheme
(cond
  ((< 5 3) "This won't run")
  ((= 5 3) "This won't run either")
  (else "Fallback value"))
```

- การทดสอบสองรายการแรกไม่ประเมินว่าเป็นจริง
- The `else` clause is executed and returns `"Fallback value"`.

ผลลัพธ์: **"ค่าทางเลือก"**

### สรุป

- ใช้ `cond` เพื่อจัดการกับเงื่อนไขต่างๆ ในลักษณะที่ชัดเจนและรัดกุม
- ผลลัพธ์ที่ตามมาอาจเป็นการแสดงออกเดี่ยวหรือการดำเนินการแบบกลุ่มโดยใช้ `begin`
- ใช้ `let` ในผลที่ตามมาเพื่อประกาศตัวแปรท้องถิ่นสำหรับการคำนวณ
- ใส่ `else` clause เป็นทางเลือกเพื่อจัดการกับกรณีที่ไม่คาดคิดเสมอ

ความยืดหยุ่นนี้ทำให้ `cond` เป็นเครื่องมือที่ทรงพลังและอ่านง่ายสำหรับการจัดการตรรกะการแยกย่อยที่ซับซ้อน