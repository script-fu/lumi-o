---
title: "Вариатические функции"
type: docs
weight: 2
---
**Функции с переменным числом аргументов** в Scheme — это функции, которые принимают переменное количество аргументов. Эти функции очень универсальны и позволяют создавать гибкий и многократно используемый код. В функциональном программировании вариативные функции упрощают операции, требующие обработки произвольного количества входных данных, например суммирование списка чисел или объединение строк.

Вариадные функции особенно полезны, когда:

- Количество аргументов не может быть определено заранее.
- Вам нужно применить ту же операцию к динамическому списку входных данных.
- Написание утилит для агрегирования или преобразования данных.

### Синтаксис вариативных функций

Функции с переменным числом аргументов определяются с помощью символа `.` перед именем последнего параметра. Этот последний параметр собирает все оставшиеся аргументы в список.

```scheme
(define (function-name fixed-parameters . variadic-parameter)
  body-expression)
```

- **`fixed-parameters`:** Любые обязательные фиксированные аргументы, которые принимает функция.
- **`variadic-parameter`:** Специальный параметр, которому предшествует `.`, который собирает дополнительные аргументы в виде списка.
- **`body-expression`:** Логика, выполняемая при вызове функции.

### Примеры функций с переменным числом аргументов

#### Базовая вариативная функция

```scheme
(define (sum . numbers)
  (apply + numbers))
```

- **Объяснение**:
  - `numbers` собирает все аргументы в список.
  - `apply` применяет функцию `+` ко всем элементам списка.

**Использование**:
```scheme
(sum 1 2 3 4 5)  ; Returns 15
```

#### Вариатическая функция с фиксированными параметрами

Вы можете комбинировать фиксированные параметры с переменным параметром для создания более гибких функций.

```scheme
(define (greet prefix . names)
  (map (lambda (name) (string-append prefix " " name)) names))
```

- **Объяснение**:
  - `prefix` — фиксированный аргумент.
  - `names` собирает оставшиеся аргументы в список.
  - Каждое имя начинается с заданной строки, используя `map` и `lambda`.

**Использование**:
```scheme
(greet "Hello" "Alice" "Bob" "Charlie")  ; Returns ("Hello Alice" "Hello Bob" "Hello Charlie")
```

#### Сочетание фиксированной и вариативной логики

```scheme
(define (describe-collection collection-name . items)
  (string-append collection-name ": " (string-join items ", ")))
```

- **Объяснение**:
  - `collection-name` — фиксированный параметр.
  - `items` собирает дополнительные аргументы в список.
  — Функция объединяет имя коллекции и элементы в одну строку.

**Использование**:
```scheme
(describe-collection "Fruits" "Apple" "Banana" "Cherry")
; Returns "Fruits: Apple, Banana, Cherry"
```

### Расширенные варианты использования

#### Обработка произвольных входных данных

Вариадические функции превосходно справляются с обработкой произвольных данных. Вот пример суммирования только положительных чисел:

```scheme
(define (sum-positive . numbers)
  (apply + (filter (lambda (x) (> x 0)) numbers)))
```

- Отфильтровывает неположительные числа перед суммированием.

**Использование**:
```scheme
(sum-positive -5 3 7 -2 8)  ; Returns 18
```

#### Функции с переменным числом переменных и рекурсивной логикой

```scheme
(define (max-value first . rest)
  (if (null? rest)
      first
      (max first (apply max rest))))
```

- **Объяснение**:
  - `first` обрабатывает первый аргумент.
  - `rest` собирает оставшиеся аргументы в список.
  - Рекурсивно вычисляет максимальное значение.

**Использование**:
```scheme
(max-value 10 20 5 40 15)  ; Returns 40
```

### Преимущества функций с вариациями

- **Гибкость:** они обрабатывают широкий спектр входных данных.
– **Краткость.** Уменьшается необходимость использования нескольких перегруженных функций.
- **Динамические операции:** включение обработки данных во время выполнения без предварительного знания количества аргументов.

### Когда использовать вариативные функции

Используйте вариативные функции, когда:

— Функции необходимо обработать неизвестное количество аргументов.
- Ко всем входным данным применяется одна операция (например, суммирование, объединение или сопоставление).
- Упрощение логики высшего порядка с помощью динамических аргументов.

Избегайте вариативных функций, если:

- Проверка ввода или проверка типов сложна.
- Фиксированных аргументов достаточно для требуемой логики.
- Читабельность ухудшается из-за слишком сложных операций.

### ЗаключениеВариативные функции в Scheme предоставляют надежный механизм обработки динамических входных данных. Понимая их синтаксис и использование, вы можете создавать гибкие и мощные сценарии, адаптирующиеся к различным сценариям. В сочетании с функциями высшего порядка вариативные функции делают ваш код более кратким и выразительным.