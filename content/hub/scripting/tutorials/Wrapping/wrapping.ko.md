---
title: "쌈"
type: docs
weight: 4
---
구성표 명령은 낮은 수준에서 작동합니다. 즉, 간단한 작업에도 여러 단계가 필요할 수 있습니다. 그러나 이러한 세분성은 유연성을 제공하므로 필요한 작업을 정확히 수행하는 작고 재사용 가능한 기능으로 명령을 묶을 수 있습니다. 포장은 흑백 개념이 아닙니다. 자주 사용되는 명령에 대한 간단한 별칭부터 전체 작업 흐름을 관리하는 보다 복잡한 기능까지 다양합니다. 때로는 래퍼가 가독성을 높이기 위한 편의 기능일 뿐인 반면, 다른 경우에는 여러 작업을 캡슐화하는 완전한 기능을 갖춘 유틸리티로 발전합니다.

### 왜 Wrap 함수를 사용하나요?

함수 래핑에는 몇 가지 주요 이점이 있습니다.

- **반복 작업 단순화** – 낮은 수준의 명령을 반복하는 대신 도우미 함수로 래핑하여 재사용하세요.
- **가독성 향상** – 래핑된 함수에 명확하고 설명이 포함된 이름을 지정하면 코드를 한 눈에 더 쉽게 이해할 수 있습니다.
- **복잡성을 캡슐화** – 길고 비밀스러운 명령 목록, 깊이 중첩된 루프 또는 복잡한 메시지 문을 처리하는 대신 이를 더 작고 잘 구조화된 도우미 함수로 나눌 수 있습니다.
- **유지관리성 향상** – 명령의 핵심 기능이 변경되는 경우 래핑된 기능을 한 번만 업데이트하면 해당 변경 사항의 세부 사항으로부터 플러그인을 격리할 수 있습니다.
- **코드 재사용 장려** – 각 도우미는 라이브러리의 일부가 되어 향후 스크립트를 더 빠르게 작성하고 디버그할 수 있습니다.

플러그인이 성장함에 따라 래퍼는 핵심 로직을 읽기 쉽게 유지하고 반복적인 세부 정보를 격리하는 데 도움이 됩니다.

함수 래핑의 또 다른 이점은 함수를 Visual Studio Code와 같은 구문 강조 표시에 통합하는 것입니다. 이를 통해 가독성과 탐색 기능이 향상되어 스크립트가 더욱 명확해집니다. 사용자 정의 함수를 사용하는 플러그인에서 녹색으로 강조 표시된 함수는 해당 함수가 라이브러리에서 올바르게 참조되었음을 확인합니다.

자체 도우미 라이브러리를 유지 관리하는 경우 편집기의 구문 강조 표시에 프로젝트의 함수 이름을 추가하는 것을 고려해 보세요. 탐색 및 리팩토링이 더 빨라집니다.

예:

### 무작위 시드

```scheme
;; Purpose: Returns a random int for seeding a filter
(define (random-seed)
  (msrg-rand))
```

코드에서 ***msrg-rand***를 직접 사용할 수도 있지만 ***random-seed***라는 함수 안에 래핑하면 가독성이 향상됩니다. 함수에 명확하고 설명적인 이름을 지정하면 함수의 목적을 한눈에 이해하기가 더 쉬워집니다.

또한 ***random-seed***를 독립형 기능으로 정의하면 플러그인의 어느 곳에서나 사용할 수 있으며 구현을 단일 위치에 중앙 집중화할 수 있습니다. 시드 생성 방법을 변경해야 하는 경우 코드의 나머지 부분은 그대로 두고 이 함수만 업데이트하면 됩니다.

예를 들어, 대신 ***random***으로 전환하기로 결정한 경우:

```scheme
;; Purpose: Returns a random int for seeding a filter
(define (random-seed)
  (random 1000))
```

함수 이름은 동일하게 유지되므로 스크립트가 수정 없이 계속 작동합니다. 이 접근 방식은 코드를 유연하고 유지 관리 가능하며 읽기 쉽게 유지합니다.

### JPEG 내보내기

Scheme의 JPEG 내보내기 기능에는 다양한 매개변수가 포함되어 있어 이미지 저장 방법을 세밀하게 제어할 수 있습니다. 그러나 대부분의 경우 파일 이름, 품질 등 몇 가지 주요 설정에만 관심이 있습니다. 프로세스를 단순화하기 위해 함수를 래핑할 수 있습니다.

```scheme
;; Purpose: Saves an image as a JPEG with a specified quality
(define (file-jpg-save image file quality)
  (let ((export-file (if (has-substring? file ".jpg")
                         file
                         (string-append file ".jpg")))) ;; Avoid jpg.jpg
    (debug-message "Exporting: " export-file)
    (file-jpeg-export #:run-mode RUN-NONINTERACTIVE
                      #:image image
                      #:file export-file
                      #:options -1
                      #:quality (* 0.01 quality)
                      #:smoothing 0.0
                      #:optimize 1
                      #:progressive 1
                      #:cmyk 0
                      #:sub-sampling "sub-sampling-1x1"
                      #:baseline 1
                      #:restart 0
                      #:dct "integer")))
```

이 래퍼 함수에서는 대부분의 내보내기 옵션이 하드코딩되어 조정될 가능성이 있는 매개변수인 파일 이름과 품질만 노출됩니다. 이 접근 방식을 사용하면 가독성이 향상되고 이미지 저장이 더 간단해집니다.또한 나중에 Lumi의 내보내기 프로그램이 변경되면 JPEG를 내보내는 모든 스크립트를 수정하는 대신 이 함수 하나만 업데이트하면 됩니다.

### 래퍼 사용

플러그인에서 JPEG를 내보내려면 라이브러리를 포함하고 사용자 정의 함수를 호출하기만 하면 됩니다.

```scheme
(file-jpg-save image "/home/mark/pictures/my-picture" 85)
```

이를 통해 코드를 깔끔하고 읽기 쉽고 적응 가능하게 유지하면서 최소한의 노력으로 효율적으로 JPEG를 내보낼 수 있습니다.

### 자동차 교체

***car*** 기능은 비밀스럽고 스크립팅 오류가 발생하기 쉽습니다. 실수로 ***car***를 벡터나 목록이 아닌 항목에 적용하여 예상치 못한 동작이 발생하기 쉽습니다. 코드를 더욱 강력하고 읽기 쉽게 만들기 위해 이 기능을 보다 안전한 함수로 래핑할 수 있습니다.

```scheme
;; Purpose: Returns the first item of a list or vector.
;;          Warns if the input is invalid or empty.
(define (first-item collection)
  (cond
    ;; Handle non-empty lists
    ((and (list? collection) (not (null? collection)))
     (list-ref collection 0))
    ;; Handle non-empty vectors
    ((and (vector? collection) (> (vector-length collection) 0))
     (vector-ref collection 0))
    ;; Invalid or empty input
    (else
     (begin
       (warning-message "first-item: Expected a non-empty list or vector, but received: " collection)
       #f))))
```

이 함수는 목록이나 벡터의 첫 번째 항목을 안전하게 검색하는 동시에 유효하지 않거나 빈 입력이 발생할 때 유용한 경고를 제공합니다. ***car*** 대신 ***첫 번째 항목***을 사용함으로써 우발적인 오류의 위험을 줄이고 스크립트의 명확성을 향상시킵니다.

#### 이 래퍼를 사용하는 이유는 무엇인가요?

- **스크립트 충돌 방지** – 목록이 아닌 항목에 ***car***를 적용하여 발생하는 오류를 방지합니다.
- **목록과 벡터 모두 지원** - 목록 이상으로 유용성을 확장합니다.
- **의미 있는 경고 제공** – 예상치 못한 입력 문제를 디버깅하는 데 도움이 됩니다.
- **가독성 향상** – 함수 이름은 해당 목적을 명확하게 전달합니다.

첫 번째 항목에 이 논리를 캡슐화함으로써 우리는 플러그인을 더욱 강력하고 유지 관리하기 쉽게 만듭니다. 물론 이는 개인 취향에 따라 다르며, car, caar, cadr 및 유사한 Scheme 기능을 직접 사용하는 것이 완전히 편할 수도 있습니다.

### 래핑된 함수 래핑하기

이미 래핑된 함수를 래핑하면 가독성과 유지 관리성이 더욱 향상될 수 있습니다. 예를 들어 ***픽셀 좌표(목록 100 200)***와 같은 좌표 쌍으로 작업할 때 다음을 사용할 수 있습니다.

```scheme
(first-item pixel-coords)
```

*x*** 좌표를 검색합니다. 그러나 기능적이긴 하지만 그다지 표현력이 좋지는 않습니다. 대신 ***첫 번째 항목***을 더 적절한 정의로 래핑하여 의도를 더 명확하게 할 수 있습니다.

```scheme
;; Purpose: Return the x-coordinate, for readability
(define (x-coord pixel-coords)
  (first-item pixel-coords))

;; Purpose: Return the y-coordinate, for readability
(define (y-coord pixel-coords)
  (second-item pixel-coords))
```

### 이 접근 방식을 사용하는 이유는 무엇입니까?

- **코드 명확성 향상** – 일반적인 목록 액세스 함수를 사용하는 대신 해당 목적을 설명하는 함수를 명시적으로 정의합니다.
- **유지관리성 향상** – 좌표 표현이 변경되는 경우(예: 목록 대신 벡터 사용) 이러한 작은 함수만 업데이트하면 됩니다.
- **일관성 향상** – ***x-좌표*** 및 ***y-좌표***를 사용하면 스크립트를 한 눈에 더 쉽게 읽고 이해할 수 있습니다.

이제 일반 구성표를 작성하는 대신 다음을 수행하십시오.

```scheme
(car pixel-coords) ;; Gets the x-coordinate
(cadr pixel-coords) ;; Gets the y-coordinate
```

우리는 _our_ Scheme으로 작성할 수 있습니다:

```scheme
(x-coord pixel-coords)
(y-coord pixel-coords)
```

하위 수준 함수를 의미 있는 이름으로 래핑함으로써 데이터 작업을 보다 직관적으로 수행하고 혼란과 잠재적인 오류를 줄일 수 있습니다.

### 제공되는 래퍼: 유틸리티 Stdlib

Lumi는 시작 시 자동으로 로드된 기성 래퍼 세트를 제공하므로 `(load ...)` 호출 없이 모든 플러그인이나 Scheme Console에서 사용할 수 있습니다. 이러한 라이브러리(`common.scm`, `files.scm`, `gegl.scm`, `images.scm`, `layers.scm`, `parasites.scm` 및 `paths.scm`)은 위의 예와 정확히 동일한 원칙을 기반으로 구축되었습니다. 낮은 수준의 작업에 이름을 지정하고, 반복되는 상용구를 숨기고, 기본 명령이 변경되면 업데이트할 수 있는 단일 위치를 제공합니다.예를 들어 `images.scm`은 원시 PDB 호출에 대한 읽기 가능한 래퍼로 `image-get-open-list`을 제공하고, `files.scm`은 반복되는 `string-append` 체인이 필요한 경로 구축 도우미를 노출합니다.

내보낸 모든 이름을 찾아보고 해당 문서 문자열을 읽고 **[Utility Browser](@@LUMI_TOKEN_21@@)**(도움말 → 프로그래밍 → 유틸리티 브라우저)에서 해당 이름이 어떤 라이브러리에서 왔는지 확인할 수 있습니다. 이는 대규모 래핑에 대한 실제적인 데모이며, 자신만의 도우미 라이브러리를 구축할 때 빌릴 수 있는 유용한 패턴 소스입니다.

### 결론

함수 래핑은 Scheme 개발을 단순화하여 스크립트를 더 읽기 쉽고 유지 관리하기 쉽고 강력하게 만드는 강력한 방법입니다. 복잡성을 캡슐화하고 필요한 세부 사항만 노출함으로써 플러그인 작성에 대한 보다 구조화된 접근 방식을 만듭니다.

이 접근 방식의 주요 내용은 다음과 같습니다.

- **반복 작업 단순화** – 낮은 수준의 명령을 수동으로 반복하는 대신 재사용 가능한 기능을 만듭니다.
- **코드 가독성 향상** – 이름이 잘 지정된 래퍼를 사용하면 스크립트를 더 쉽게 이해할 수 있습니다.
- **복잡성 캡슐화** – 낮은 수준의 세부 사항은 래퍼 내부에서 처리되어 기본 스크립트를 깔끔하게 유지합니다.
- **유지관리성 향상** – 핵심 기능이 변경되면 래퍼에 의존하는 모든 스크립트가 아닌 래퍼만 업데이트하면 됩니다.
- **재사용 및 일관성 장려** – 시간이 지남에 따라 개인 기능 라이브러리가 확장되어 개발 속도와 효율성이 향상됩니다.

함수 래핑을 일관되게 사용함으로써 Scheme 플러그인 작성 방법을 변화시켜 보다 모듈화되고 표현력이 풍부한 스크립팅 환경을 만들 수 있습니다. 이러한 원칙을 염두에 두고 우리는 접근 방식을 지속적으로 개선하여 특정 요구 사항을 충족하는 보다 효율적이고 맞춤화된 Scheme 버전을 개발할 수 있습니다.

다음 단계: 스크립트에서 반복되는 블록을 식별하고 명확한 이름을 가진 작은 도우미를 추출합니다.